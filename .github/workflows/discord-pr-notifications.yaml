name: Discord PR Notifications

on:
  pull_request:
    types: [opened, review_requested, review_request_removed, synchronize]
  pull_request_review:
    types: [submitted, dismissed]

jobs:
  handle-pr-opened:
    if: github.event_name == 'pull_request' && github.event.action == 'opened'
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      issues: write
    steps:
      - name: Handle PR Opened
        uses: actions/github-script@v7
        env:
          DISCORD_BOT_TOKEN: ${{ secrets.DISCORD_BOT_TOKEN }}
          DISCORD_CHANNEL_ID: ${{ secrets.DISCORD_PR_CHANNEL_ID }}
          DISCORD_USER_MAPPING: ${{ secrets.DISCORD_USER_MAPPING }}
          DISCORD_OPERATIONS_ROLE_ID: ${{ secrets.DISCORD_OPERATIONS_ROLE_ID }}
        with:
          script: |
            const pr = context.payload.pull_request;
            const isDraft = pr.draft;
            const prNumber = pr.number;
            const prTitle = pr.title;
            const prUrl = pr.html_url;
            const author = pr.user.login;
            const baseBranch = pr.base.ref;
            
            // Get reviewers
            const reviewers = pr.requested_reviewers || [];
            const reviewerLogins = reviewers.map(r => r.login);
            
            // Load user mapping
            const userMapping = process.env.DISCORD_USER_MAPPING 
              ? JSON.parse(process.env.DISCORD_USER_MAPPING) 
              : {};
            
            // Map GitHub usernames to Discord user IDs
            const mapToDiscord = (githubUsername) => {
              return userMapping[githubUsername] 
                ? `<@${userMapping[githubUsername]}>` 
                : `@${githubUsername}`;
            };
            
            // Build message
            const draftPrefix = isDraft ? 'üìù **DRAFT** ' : '';
            let message = `${draftPrefix}üîÄ **New Pull Request**\n\n`;
            message += `[PR #${prNumber}: ${prTitle}](${prUrl})\n`;
            message += `Author: ${mapToDiscord(author)}\n`;
            
            if (reviewerLogins.length > 0) {
              const reviewerMentions = reviewerLogins.map(mapToDiscord).join(' ');
              message += `Reviewers: ${reviewerMentions}\n`;
            } else {
              message += `\n‚ö†Ô∏è No reviewers assigned. Please add reviewers to this PR.\n`;
            }
            
            // Post to Discord
            const channelId = process.env.DISCORD_CHANNEL_ID;
            const botToken = process.env.DISCORD_BOT_TOKEN;
            
            if (!botToken || !channelId) {
              core.setFailed('DISCORD_BOT_TOKEN and DISCORD_CHANNEL_ID secrets must be set');
              return;
            }
            
            // Send message to Discord
            const messageResponse = await fetch(`https://discord.com/api/v10/channels/${channelId}/messages`, {
              method: 'POST',
              headers: {
                'Authorization': `Bot ${botToken}`,
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                content: message,
                flags: 4 // Suppress embeds
              })
            });
            
            if (!messageResponse.ok) {
              const errorText = await messageResponse.text();
              core.setFailed(`Failed to send Discord message: ${errorText}`);
              return;
            }
            
            const messageData = await messageResponse.json();
            const discordMessageId = messageData.id;
            
            // Create thread
            const threadName = `PR #${prNumber}: ${prTitle}`.substring(0, 100); // Discord thread name limit
            const threadResponse = await fetch(`https://discord.com/api/v10/channels/${channelId}/messages/${discordMessageId}/threads`, {
              method: 'POST',
              headers: {
                'Authorization': `Bot ${botToken}`,
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                name: threadName,
                auto_archive_duration: 1440 // 24 hours
              })
            });
            
            if (!threadResponse.ok) {
              const errorText = await threadResponse.text();
              core.warning(`Failed to create thread: ${errorText}`);
            } else {
              const threadData = await threadResponse.json();
              const threadId = threadData.id;
              
              // Post thread message
              await fetch(`https://discord.com/api/v10/channels/${threadId}/messages`, {
                method: 'POST',
                headers: {
                  'Authorization': `Bot ${botToken}`,
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                  content: 'üí¨ Please keep PR discussions in this thread or in the PR comments on GitHub'
                })
              });
              
              // Store metadata in PR comment
              const metadata = {
                message_id: discordMessageId,
                thread_id: threadId,
                channel_id: channelId
              };
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: `<!-- DISCORD_BOT_METADATA\n${JSON.stringify(metadata, null, 2)}\n-->`
              });
            }

## REVIEWER ACTIONS ##
  handle-reviewer-added:
    if: github.event_name == 'pull_request' && github.event.action == 'review_requested'
    runs-on: ubuntu-latest
    permissions:
      pull-requests: read
      issues: read
    steps:
      - name: Handle Reviewer Added
        uses: actions/github-script@v7
        env:
          DISCORD_BOT_TOKEN: ${{ secrets.DISCORD_BOT_TOKEN }}
          DISCORD_USER_MAPPING: ${{ secrets.DISCORD_USER_MAPPING }}
        with:
          script: |
            const pr = context.payload.pull_request;
            const prNumber = pr.number;

            // Get ALL current reviewers from PR (not just the one that triggered the event)
            const allReviewers = pr.requested_reviewers || [];
            const allReviewerLogins = allReviewers.map(r => r.login);

            // Get the specific reviewer that triggered this event (for thread notification)
            const requestedReviewer = context.payload.requested_reviewer;
            const reviewerLogin = requestedReviewer ? requestedReviewer.login : null;

            // Get bot token
            const botToken = process.env.DISCORD_BOT_TOKEN;
            if (!botToken) {
            core.setFailed('DISCORD_BOT_TOKEN secret must be set');
            return;
            }

            // Load user mapping
            const userMapping = process.env.DISCORD_USER_MAPPING 
            ? JSON.parse(process.env.DISCORD_USER_MAPPING) 
            : {};

            const mapToDiscord = (githubUsername) => {
            return userMapping[githubUsername] 
                ? `<@${userMapping[githubUsername]}>` 
                : `@${githubUsername}`;
            };

            // Find metadata comment
            const comments = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: prNumber
            });

            let metadata = null;
            for (const comment of comments.data) {
            const match = comment.body.match(/<!-- DISCORD_BOT_METADATA\n([\s\S]*?)\n-->/);
            if (match) {
                try {
                metadata = JSON.parse(match[1]);
                break;
                } catch (e) {
                core.warning(`Failed to parse metadata: ${e.message}`);
                }
            }
            }

            if (!metadata || !metadata.thread_id) {
            core.warning('No Discord thread found for this PR. Skipping.');
            return;
            }

            // Post in thread for the newly added reviewer(s)
            if (reviewerLogin) {
            const reviewerMention = mapToDiscord(reviewerLogin);
            await fetch(`https://discord.com/api/v10/channels/${metadata.thread_id}/messages`, {
                method: 'POST',
                headers: {
                'Authorization': `Bot ${botToken}`,
                'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                content: `${reviewerMention} You've been added as a reviewer to this PR!`
                })
            });
            }

            // Update parent message with ALL current reviewers (handles multiple additions)
            try {
            const messageResponse = await fetch(`https://discord.com/api/v10/channels/${metadata.channel_id}/messages/${metadata.message_id}`, {
                method: 'GET',
                headers: {
                'Authorization': `Bot ${botToken}`
                }
            });
            
            if (messageResponse.ok) {
                const messageData = await messageResponse.json();
                let content = messageData.content;
                
                // Extract the parts before and after the reviewers section
                const lines = content.split('\n');
                let beforeReviewers = [];
                let afterReviewers = [];
                let reviewersLineIndex = -1;
                
                // Find the reviewers line or no reviewers warning
                for (let i = 0; i < lines.length; i++) {
                if (lines[i].includes('Reviewers:') || lines[i].includes('‚ö†Ô∏è No reviewers assigned')) {
                    reviewersLineIndex = i;
                    break;
                }
                }
                
                if (reviewersLineIndex >= 0) {
                beforeReviewers = lines.slice(0, reviewersLineIndex);
                afterReviewers = lines.slice(reviewersLineIndex + 1);
                } else {
                // If no reviewers line found, assume it should be after the Author line
                const authorLineIndex = lines.findIndex(line => line.startsWith('Author:'));
                if (authorLineIndex >= 0) {
                    beforeReviewers = lines.slice(0, authorLineIndex + 1);
                    afterReviewers = lines.slice(authorLineIndex + 1);
                } else {
                    beforeReviewers = lines;
                    afterReviewers = [];
                }
                }
                
                // Rebuild the message with current reviewers
                const rebuiltLines = [...beforeReviewers];
                
                if (allReviewerLogins.length > 0) {
                const reviewerMentions = allReviewerLogins.map(mapToDiscord).join(' ');
                rebuiltLines.push(`Reviewers: ${reviewerMentions}`);
                } else {
                rebuiltLines.push(`\n‚ö†Ô∏è No reviewers assigned. Please add reviewers to this PR.`);
                }
                
                rebuiltLines.push(...afterReviewers);
                content = rebuiltLines.join('\n');
                
                // Edit the message
                await fetch(`https://discord.com/api/v10/channels/${metadata.channel_id}/messages/${metadata.message_id}`, {
                method: 'PATCH',
                headers: {
                    'Authorization': `Bot ${botToken}`,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    content: content,
                    flags: 4 // Suppress embeds
                })
                });
            }
            } catch (e) {
            core.warning(`Failed to edit parent message: ${e.message}`);
            }
            
  handle-reviewer-removed:
    if: github.event_name == 'pull_request' && github.event.action == 'review_request_removed'
    runs-on: ubuntu-latest
    permissions:
        pull-requests: read
        issues: read
    steps:
      - name: Handle Reviewer Removed
        uses: actions/github-script@v7
        env:
            DISCORD_BOT_TOKEN: ${{ secrets.DISCORD_BOT_TOKEN }}
            DISCORD_USER_MAPPING: ${{ secrets.DISCORD_USER_MAPPING }}
        with:
          script: |
            const pr = context.payload.pull_request;
            const prNumber = pr.number;
            
            // Get ALL current reviewers from PR (after removal)
            const allReviewers = pr.requested_reviewers || [];
            const allReviewerLogins = allReviewers.map(r => r.login);

            // Get the specific reviewer that was removed (for thread notification)
            const removedReviewer = context.payload.requested_reviewer;
            const removedReviewerLogin = removedReviewer ? removedReviewer.login : null;

            // Get bot token
            const botToken = process.env.DISCORD_BOT_TOKEN;
            if (!botToken) 
            {
                core.setFailed('DISCORD_BOT_TOKEN secret must be set');
                return;
            }

            // Load user mapping
            const userMapping = process.env.DISCORD_USER_MAPPING 
                ? JSON.parse(process.env.DISCORD_USER_MAPPING) 
                : {};

            const mapToDiscord = (githubUsername) => 
            {
                return userMapping[githubUsername] 
                ? `<@${userMapping[githubUsername]}>` 
                : `@${githubUsername}`;
            };

            // Find metadata comment
            const comments = await github.rest.issues.listComments(
              {
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber
              }
                );

            let metadata = null;
            for (const comment of comments.data) 
            {
                const match = comment.body.match(/<!-- DISCORD_BOT_METADATA\n([\s\S]*?)\n-->/);
                if (match) 
                {
                  try {
                    metadata = JSON.parse(match[1]);
                    break;
                  } catch (e) 
                  {
                    core.warning(`Failed to parse metadata: ${e.message}`);
                  }
                }
            }

            if (!metadata || !metadata.thread_id) 
            {
                core.warning('No Discord thread found for this PR. Skipping.');
                return;
            }

            // Post in thread for the removed reviewer
            if (removedReviewerLogin) 
            {
                const removedReviewerMention = mapToDiscord(removedReviewerLogin);
                await fetch(`https://discord.com/api/v10/channels/${metadata.thread_id}/messages`, 
                    {
                      method: 'POST',
                      headers: 
                      {
                        'Authorization': `Bot ${botToken}`,
                        'Content-Type': 'application/json',
                      },
                      body: JSON.stringify(
                        {
                            content: `üëã ${removedReviewerMention} has been removed as a reviewer from this PR.`
                        }
                      )
                    });

                // Remove reviewer from thread
                if (userMapping[removedReviewerLogin]) 
                {
                    const discordUserId = userMapping[removedReviewerLogin];
                    try 
                    {
                        const removeResponse = await fetch(`https://discord.com/api/v10/channels/${metadata.thread_id}/thread-members/${discordUserId}`, 
                        {
                          method: 'DELETE',
                          headers: 
                            {
                                'Authorization': `Bot ${botToken}`
                            }
                        });
                        
                        if (removeResponse.ok) 
                        {
                          core.info(`Removed ${removedReviewerLogin} from Discord thread`);
                        } else if (removeResponse.status === 404) 
                        {
                          // User not in thread - that's okay
                          core.info(`${removedReviewerLogin} was not in the thread`);
                        } else 
                        {
                          const errorText = await removeResponse.text();
                          core.warning(`Failed to remove ${removedReviewerLogin} from thread: ${errorText}`);
                        }
                    } catch (e) 
                    {
                        core.warning(`Error removing ${removedReviewerLogin} from thread: ${e.message}`);
                    }
                }
            }

            // Update parent message with ALL current reviewers (after removal)
            try 
            {
                const messageResponse = await fetch(`https://discord.com/api/v10/channels/${metadata.channel_id}/messages/${metadata.message_id}`, 
                {
                  method: 'GET',
                  headers: 
                  {
                    'Authorization': `Bot ${botToken}`
                  }
                });
                
                if (messageResponse.ok) 
                {
                    const messageData = await messageResponse.json();
                    let content = messageData.content;
                    
                    // Extract the parts before and after the reviewers section
                    const lines = content.split('\n');
                    let beforeReviewers = [];
                    let afterReviewers = [];
                    let reviewersLineIndex = -1;
                    
                    // Find the reviewers line or no reviewers warning
                    for (let i = 0; i < lines.length; i++) 
                    {
                        if (lines[i].includes('Reviewers:') || lines[i].includes('‚ö†Ô∏è No reviewers assigned')) 
                        {
                          reviewersLineIndex = i;
                          break;
                        }
                    }
                }
                
                if (reviewersLineIndex >= 0) 
                {
                    beforeReviewers = lines.slice(0, reviewersLineIndex);
                    afterReviewers = lines.slice(reviewersLineIndex + 1);
                } else 
                {
                    // If no reviewers line found, assume it should be after the Author line
                    const authorLineIndex = lines.findIndex(line => line.startsWith('Author:'));
                    if (authorLineIndex >= 0) 
                    {
                        beforeReviewers = lines.slice(0, authorLineIndex + 1);
                        afterReviewers = lines.slice(authorLineIndex + 1);
                    } else 
                    {
                        beforeReviewers = lines;
                        afterReviewers = [];
                    }
                }
                
                // Rebuild the message with current reviewers
                const rebuiltLines = [...beforeReviewers];
                
                if (allReviewerLogins.length > 0) 
                {
                    const reviewerMentions = allReviewerLogins.map(mapToDiscord).join(' ');
                    rebuiltLines.push(`Reviewers: ${reviewerMentions}`);
                } else 
                 {
                    rebuiltLines.push(`\n‚ö†Ô∏è No reviewers assigned. Please add reviewers to this PR.`);
                }
                
                rebuiltLines.push(...afterReviewers);
                content = rebuiltLines.join('\n');
                
                // Edit the message
                await fetch(`https://discord.com/api/v10/channels/${metadata.channel_id}/messages/${metadata.message_id}`, 
                {
                    method: 'PATCH',
                    headers: 
                      {
                        'Authorization': `Bot ${botToken}`,
                        'Content-Type': 'application/json',
                      },
                    body: JSON.stringify(
                    {
                        content: content,
                        flags: 4 // Suppress embeds
                    })
                });
            } catch (e) 
            {
                core.warning(`Failed to edit parent message: ${e.message}`);
            } 
                
  handle-pr-review:
    if: github.event_name == 'pull_request_review'
    runs-on: ubuntu-latest
    permissions:
      pull-requests: read
      issues: read
    steps:
      - name: Handle PR Review
        uses: actions/github-script@v7
        env:
            DISCORD_BOT_TOKEN: ${{ secrets.DISCORD_BOT_TOKEN }}
            DISCORD_USER_MAPPING: ${{ secrets.DISCORD_USER_MAPPING }}
            DISCORD_OPERATIONS_ROLE_ID: ${{ secrets.DISCORD_OPERATIONS_ROLE_ID }}
        with:
            script: |
                const pr = context.payload.pull_request; 
                const review = context.payload.review;
                const prNumber = pr.number;
                const baseBranch = pr.base.ref;
                const author = pr.user.login;
                const reviewer = review.user.login;
                const reviewState = review.state; // 'approved', 'changes_requested', or 'commented'
                
                // Get the review body - try from payload first, then fetch from API if needed
                let reviewBody = review.body || '';

                // If review body is empty, try fetching the full review details
                if (!reviewBody || reviewBody.trim() === '') 
                {
                    try 
                    {
                        const fullReview = await github.rest.pulls.getReview({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        pull_number: prNumber,
                        review_id: review.id
                        });
                        reviewBody = fullReview.data.body || '';
                    } catch (e) 
                    {
                        core.warning(`Could not fetch review details: ${e.message}`);
                        reviewBody = '';
                    }
                }
                
                // Skip if it's just a comment (not approval or changes requested)
                if (reviewState === 'commented') {
                    core.info('Review is just a comment, skipping.');
                    return;
                }
                
                // Get bot token
                const botToken = process.env.DISCORD_BOT_TOKEN;
                if (!botToken) {
                    core.setFailed('DISCORD_BOT_TOKEN secret must be set');
                    return;
                }
                
                // Load user mapping
                const userMapping = process.env.DISCORD_USER_MAPPING 
                    ? JSON.parse(process.env.DISCORD_USER_MAPPING) 
                    : {};
                
                const mapToDiscord = (githubUsername) => {
                    return userMapping[githubUsername] 
                    ? `<@${userMapping[githubUsername]}>` 
                    : `@${githubUsername}`;
                };
                
                // Find metadata comment
                const comments = await github.rest.issues.listComments({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber
                });
                
                let metadata = null;
                for (const comment of comments.data) {
                    const match = comment.body.match(/<!-- DISCORD_BOT_METADATA\n([\s\S]*?)\n-->/);
                    if (match) {
                    try {
                        metadata = JSON.parse(match[1]);
                        break;
                    } catch (e) {
                        core.warning(`Failed to parse metadata: ${e.message}`);
                    }
                    }
                }
                
                if (!metadata) {
                    core.warning('No Discord metadata found for this PR. Skipping.');
                    return;
                }
                
                // Determine emoji and status text based on review state
                let emoji = '';
                let statusText = '';
                if (reviewState === 'approved') {
                    emoji = '‚úÖ';
                    statusText = 'APPROVED';
                } else if (reviewState === 'changes_requested') {
                    emoji = '‚ùå';
                    statusText = 'CHANGES REQUESTED';
                }
                
                // Add reaction to parent message
                if (emoji) {
                    await fetch(`https://discord.com/api/v10/channels/${metadata.channel_id}/messages/${metadata.message_id}/reactions/${emoji}/@me`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bot ${botToken}`
                    }
                    });
                }
                
                // Build review message for thread
                const reviewerMention = mapToDiscord(reviewer);
                const authorMention = mapToDiscord(author);
                let reviewMessage = `${emoji} **${statusText} BY** ${reviewerMention}\n\n`;
                
                // Debug: log review body
                core.info(`Review body from payload: ${review.body || '(empty)'}`);
                core.info(`Review body after fetch: ${reviewBody || '(empty)'}`)

                if (reviewBody && reviewBody.trim() !== '') {
                  reviewMessage += `> ${reviewBody.replace(/\n/g, '\n> ')}\n\n`;
                } else {
                  // If no review body, still add a note
                  if (reviewState === 'approved') {
                    reviewMessage += `> Approved without comment\n\n`;
                  } else if (reviewState === 'changes_requested') {
                    reviewMessage += `> Changes requested\n\n`;
                  }
                }

                // Add merge instructions for approvals
                if (reviewState === 'approved') {
                if (baseBranch === 'dev') {
                    reviewMessage += `${authorMention} Ready to merge! üöÄ`;
                } else {
                    const operationsRoleId = process.env.DISCORD_OPERATIONS_ROLE_ID;
                    const operationsMention = operationsRoleId ? `<@&${operationsRoleId}>` : '@Operations';
                    reviewMessage += `${authorMention} ${operationsMention} Ready to merge! üöÄ`;
                }
                } else if (reviewState === 'changes_requested') {
                reviewMessage += `${authorMention} Please address the requested changes.`;
                }
                
                // Post in thread
                if (metadata.thread_id) {
                    await fetch(`https://discord.com/api/v10/channels/${metadata.thread_id}/messages`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bot ${botToken}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        content: reviewMessage
                    })
                    });
                }
                
                // Update parent message with review status
                try {
                    const messageResponse = await fetch(`https://discord.com/api/v10/channels/${metadata.channel_id}/messages/${metadata.message_id}`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bot ${botToken}`
                    }
                    });
                    
                    if (messageResponse.ok) {
                    const messageData = await messageResponse.json();
                    let content = messageData.content;
                    
                    // Check if there's already a review status line
                    const lines = content.split('\n');
                    let newLines = [];
                    let statusLineAdded = false;
                    
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i];
                        
                        // Replace existing review status if found
                        if (line.includes('‚úÖ APPROVED') || line.includes('‚ùå CHANGES REQUESTED')) {
                        newLines.push(`${emoji} **${statusText}** by ${reviewerMention}`);
                        statusLineAdded = true;
                        } else if (!statusLineAdded && (line.includes('Reviewers:') || line.includes('‚ö†Ô∏è No reviewers assigned'))) {
                        // Add status after reviewers line
                        newLines.push(line);
                        newLines.push(`${emoji} **${statusText}** by ${reviewerMention}`);
                        statusLineAdded = true;
                        } else {
                        newLines.push(line);
                        }
                    }
                    
                    // If no status line was found/added, add it at the end before any existing content
                    if (!statusLineAdded) {
                        // Find a good place to insert (after reviewers or author)
                        const reviewersIndex = newLines.findIndex(line => line.includes('Reviewers:') || line.includes('‚ö†Ô∏è No reviewers assigned'));
                        if (reviewersIndex >= 0) {
                        newLines.splice(reviewersIndex + 1, 0, `${emoji} **${statusText}** by ${reviewerMention}`);
                        } else {
                        newLines.push(`${emoji} **${statusText}** by ${reviewerMention}`);
                        }
                    }
                    
                    content = newLines.join('\n');
                    
                    // Edit the message
                    await fetch(`https://discord.com/api/v10/channels/${metadata.channel_id}/messages/${metadata.message_id}`, {
                        method: 'PATCH',
                        headers: {
                        'Authorization': `Bot ${botToken}`,
                        'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                        content: content,
                        flags: 4 // Suppress embeds
                        })
                    });
                    }
                } catch (e) {
                    core.warning(`Failed to edit parent message: ${e.message}`);
                }

  handle-review-dismissed:
    if: github.event_name == 'pull_request_review' && github.event.action == 'dismissed'
    runs-on: ubuntu-latest
    permissions:
      pull-requests: read
      issues: read
    steps:
      - name: Handle Review Dismissed
        uses: actions/github-script@v7
        env:
          DISCORD_BOT_TOKEN: ${{ secrets.DISCORD_BOT_TOKEN }}
          DISCORD_USER_MAPPING: ${{ secrets.DISCORD_USER_MAPPING }}
        with:
            script: |
                const pr = context.payload.pull_request;
                const review = context.payload.review;
                const prNumber = pr.number;
                const reviewer = review.user.login;
                const reviewState = review.state; // The original state before dismissal
                
                // Only notify if it was a changes_requested review
                if (reviewState !== 'changes_requested') {
                    core.info('Dismissed review was not changes_requested, skipping.');
                    return;
                }
                
                // Get bot token
                const botToken = process.env.DISCORD_BOT_TOKEN;
                if (!botToken) {
                    core.setFailed('DISCORD_BOT_TOKEN secret must be set');
                    return;
                }
                
                // Load user mapping
                const userMapping = process.env.DISCORD_USER_MAPPING 
                    ? JSON.parse(process.env.DISCORD_USER_MAPPING) 
                    : {};
                
                const mapToDiscord = (githubUsername) => {
                    return userMapping[githubUsername] 
                    ? `<@${userMapping[githubUsername]}>` 
                    : `@${githubUsername}`;
                };
                
                // Find metadata comment
                const comments = await github.rest.issues.listComments({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber
                });
                
                let metadata = null;
                for (const comment of comments.data) {
                    const match = comment.body.match(/<!-- DISCORD_BOT_METADATA\n([\s\S]*?)\n-->/);
                    if (match) {
                    try {
                        metadata = JSON.parse(match[1]);
                        break;
                    } catch (e) {
                        core.warning(`Failed to parse metadata: ${e.message}`);
                    }
                    }
                }
                
                if (!metadata || !metadata.thread_id) {
                    core.warning('No Discord thread found for this PR. Skipping.');
                    return;
                }
                
                // Post in thread to notify the reviewer
                const reviewerMention = mapToDiscord(reviewer);
                await fetch(`https://discord.com/api/v10/channels/${metadata.thread_id}/messages`, {
                    method: 'POST',
                    headers: {
                    'Authorization': `Bot ${botToken}`,
                    'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                    content: `‚úÖ ${reviewerMention} The requested changes have been addressed. Please review the updates.`
                    })
                });