name: Discord PR Notifications

on:
  pull_request:
    types: [opened, review_requested, review_request_removed]

jobs:
  handle-pr-opened:
    if: github.event_name == 'pull_request' && github.event.action == 'opened'
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      issues: write
    steps:
      - name: Handle PR Opened
        uses: actions/github-script@v7
        env:
          DISCORD_BOT_TOKEN: ${{ secrets.DISCORD_BOT_TOKEN }}
          DISCORD_CHANNEL_ID: ${{ secrets.DISCORD_PR_CHANNEL_ID }}
          DISCORD_USER_MAPPING: ${{ secrets.DISCORD_USER_MAPPING }}
          DISCORD_OPERATIONS_ROLE_ID: ${{ secrets.DISCORD_OPERATIONS_ROLE_ID }}
        with:
          script: |
            const pr = context.payload.pull_request;
            const isDraft = pr.draft;
            const prNumber = pr.number;
            const prTitle = pr.title;
            const prUrl = pr.html_url;
            const author = pr.user.login;
            const baseBranch = pr.base.ref;
            
            // Get reviewers
            const reviewers = pr.requested_reviewers || [];
            const reviewerLogins = reviewers.map(r => r.login);
            
            // Load user mapping
            const userMapping = process.env.DISCORD_USER_MAPPING 
              ? JSON.parse(process.env.DISCORD_USER_MAPPING) 
              : {};
            
            // Map GitHub usernames to Discord user IDs
            const mapToDiscord = (githubUsername) => {
              return userMapping[githubUsername] 
                ? `<@${userMapping[githubUsername]}>` 
                : `@${githubUsername}`;
            };
            
            // Build message
            const draftPrefix = isDraft ? 'üìù **DRAFT** ' : '';
            let message = `${draftPrefix}üîÄ **New Pull Request**\n\n`;
            message += `[PR #${prNumber}: ${prTitle}](${prUrl})\n`;
            message += `Author: ${mapToDiscord(author)}\n`;
            
            if (reviewerLogins.length > 0) {
              const reviewerMentions = reviewerLogins.map(mapToDiscord).join(' ');
              message += `Reviewers: ${reviewerMentions}\n`;
            } else {
              message += `\n‚ö†Ô∏è No reviewers assigned. Please add reviewers to this PR.\n`;
            }
            
            // Post to Discord
            const channelId = process.env.DISCORD_CHANNEL_ID;
            const botToken = process.env.DISCORD_BOT_TOKEN;
            
            if (!botToken || !channelId) {
              core.setFailed('DISCORD_BOT_TOKEN and DISCORD_CHANNEL_ID secrets must be set');
              return;
            }
            
            // Send message to Discord
            const messageResponse = await fetch(`https://discord.com/api/v10/channels/${channelId}/messages`, {
              method: 'POST',
              headers: {
                'Authorization': `Bot ${botToken}`,
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                content: message,
                flags: 4 // Suppress embeds
              })
            });
            
            if (!messageResponse.ok) {
              const errorText = await messageResponse.text();
              core.setFailed(`Failed to send Discord message: ${errorText}`);
              return;
            }
            
            const messageData = await messageResponse.json();
            const discordMessageId = messageData.id;
            
            // Create thread
            const threadName = `PR #${prNumber}: ${prTitle}`.substring(0, 100); // Discord thread name limit
            const threadResponse = await fetch(`https://discord.com/api/v10/channels/${channelId}/messages/${discordMessageId}/threads`, {
              method: 'POST',
              headers: {
                'Authorization': `Bot ${botToken}`,
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                name: threadName,
                auto_archive_duration: 1440 // 24 hours
              })
            });
            
            if (!threadResponse.ok) {
              const errorText = await threadResponse.text();
              core.warning(`Failed to create thread: ${errorText}`);
            } else {
              const threadData = await threadResponse.json();
              const threadId = threadData.id;
              
              // Post thread message
              await fetch(`https://discord.com/api/v10/channels/${threadId}/messages`, {
                method: 'POST',
                headers: {
                  'Authorization': `Bot ${botToken}`,
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                  content: 'üí¨ Please keep PR discussions in this thread or in the PR comments on GitHub'
                })
              });
              
              // Store metadata in PR comment
              const metadata = {
                message_id: discordMessageId,
                thread_id: threadId,
                channel_id: channelId
              };
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: `<!-- DISCORD_BOT_METADATA\n${JSON.stringify(metadata, null, 2)}\n-->`
              });
            }

  handle-reviewer-added:
    if: github.event_name == 'pull_request' && github.event.action == 'review_requested'
    runs-on: ubuntu-latest
    permissions:
      pull-requests: read
      issues: read
    steps:
      - name: Handle Reviewer Added
        uses: actions/github-script@v7
        env:
          DISCORD_BOT_TOKEN: ${{ secrets.DISCORD_BOT_TOKEN }}
          DISCORD_USER_MAPPING: ${{ secrets.DISCORD_USER_MAPPING }}
        with:
          script: |
            const pr = context.payload.pull_request;
            const prNumber = pr.number;

            // Get ALL current reviewers from PR (not just the one that triggered the event)
            const allReviewers = pr.requested_reviewers || [];
            const allReviewerLogins = allReviewers.map(r => r.login);

            // Get the specific reviewer that triggered this event (for thread notification)
            const requestedReviewer = context.payload.requested_reviewer;
            const reviewerLogin = requestedReviewer ? requestedReviewer.login : null;

            // Get bot token
            const botToken = process.env.DISCORD_BOT_TOKEN;
            if (!botToken) {
            core.setFailed('DISCORD_BOT_TOKEN secret must be set');
            return;
            }

            // Load user mapping
            const userMapping = process.env.DISCORD_USER_MAPPING 
            ? JSON.parse(process.env.DISCORD_USER_MAPPING) 
            : {};

            const mapToDiscord = (githubUsername) => {
            return userMapping[githubUsername] 
                ? `<@${userMapping[githubUsername]}>` 
                : `@${githubUsername}`;
            };

            // Find metadata comment
            const comments = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: prNumber
            });

            let metadata = null;
            for (const comment of comments.data) {
            const match = comment.body.match(/<!-- DISCORD_BOT_METADATA\n([\s\S]*?)\n-->/);
            if (match) {
                try {
                metadata = JSON.parse(match[1]);
                break;
                } catch (e) {
                core.warning(`Failed to parse metadata: ${e.message}`);
                }
            }
            }

            if (!metadata || !metadata.thread_id) {
            core.warning('No Discord thread found for this PR. Skipping.');
            return;
            }

            // Post in thread for the newly added reviewer(s)
            if (reviewerLogin) {
            const reviewerMention = mapToDiscord(reviewerLogin);
            await fetch(`https://discord.com/api/v10/channels/${metadata.thread_id}/messages`, {
                method: 'POST',
                headers: {
                'Authorization': `Bot ${botToken}`,
                'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                content: `${reviewerMention} You've been added as a reviewer to this PR!`
                })
            });
            }

            // Update parent message with ALL current reviewers (handles multiple additions)
            try {
            const messageResponse = await fetch(`https://discord.com/api/v10/channels/${metadata.channel_id}/messages/${metadata.message_id}`, {
                method: 'GET',
                headers: {
                'Authorization': `Bot ${botToken}`
                }
            });
            
            if (messageResponse.ok) {
                const messageData = await messageResponse.json();
                let content = messageData.content;
                
                // Extract the parts before and after the reviewers section
                const lines = content.split('\n');
                let beforeReviewers = [];
                let afterReviewers = [];
                let reviewersLineIndex = -1;
                
                // Find the reviewers line or no reviewers warning
                for (let i = 0; i < lines.length; i++) {
                if (lines[i].includes('Reviewers:') || lines[i].includes('‚ö†Ô∏è No reviewers assigned')) {
                    reviewersLineIndex = i;
                    break;
                }
                }
                
                if (reviewersLineIndex >= 0) {
                beforeReviewers = lines.slice(0, reviewersLineIndex);
                afterReviewers = lines.slice(reviewersLineIndex + 1);
                } else {
                // If no reviewers line found, assume it should be after the Author line
                const authorLineIndex = lines.findIndex(line => line.startsWith('Author:'));
                if (authorLineIndex >= 0) {
                    beforeReviewers = lines.slice(0, authorLineIndex + 1);
                    afterReviewers = lines.slice(authorLineIndex + 1);
                } else {
                    beforeReviewers = lines;
                    afterReviewers = [];
                }
                }
                
                // Rebuild the message with current reviewers
                const rebuiltLines = [...beforeReviewers];
                
                if (allReviewerLogins.length > 0) {
                const reviewerMentions = allReviewerLogins.map(mapToDiscord).join(' ');
                rebuiltLines.push(`Reviewers: ${reviewerMentions}`);
                } else {
                rebuiltLines.push(`\n‚ö†Ô∏è No reviewers assigned. Please add reviewers to this PR.`);
                }
                
                rebuiltLines.push(...afterReviewers);
                content = rebuiltLines.join('\n');
                
                // Edit the message
                await fetch(`https://discord.com/api/v10/channels/${metadata.channel_id}/messages/${metadata.message_id}`, {
                method: 'PATCH',
                headers: {
                    'Authorization': `Bot ${botToken}`,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    content: content,
                    flags: 4 // Suppress embeds
                })
                });
            }
            } catch (e) {
            core.warning(`Failed to edit parent message: ${e.message}`);
            }
            
  handle-reviewer-removed:
    if: github.event_name == 'pull_request' && github.event.action == 'review_request_removed'
    runs-on: ubuntu-latest
    permissions:
        pull-requests: read
        issues: read
    steps:
      - name: Handle Reviewer Removed
        uses: actions/github-script@v7
        env:
            DISCORD_BOT_TOKEN: ${{ secrets.DISCORD_BOT_TOKEN }}
            DISCORD_USER_MAPPING: ${{ secrets.DISCORD_USER_MAPPING }}
        with:
          script: |
            const pr = context.payload.pull_request;
            const prNumber = pr.number;
            
            // Get ALL current reviewers from PR (after removal)
            const allReviewers = pr.requested_reviewers || [];
            const allReviewerLogins = allReviewers.map(r => r.login);

            // Get the specific reviewer that was removed (for thread notification)
            const removedReviewer = context.payload.requested_reviewer;
            const removedReviewerLogin = removedReviewer ? removedReviewer.login : null;

            // Get bot token
            const botToken = process.env.DISCORD_BOT_TOKEN;
            if (!botToken) {
                core.setFailed('DISCORD_BOT_TOKEN secret must be set');
                return;
            }

            // Load user mapping
            const userMapping = process.env.DISCORD_USER_MAPPING 
                ? JSON.parse(process.env.DISCORD_USER_MAPPING) 
                : {};

            const mapToDiscord = (githubUsername) => {
                return userMapping[githubUsername] 
                ? `<@${userMapping[githubUsername]}>` 
                : `@${githubUsername}`;
            };

            // Find metadata comment
            const comments = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber
            });

            let metadata = null;
            for (const comment of comments.data) {
                const match = comment.body.match(/<!-- DISCORD_BOT_METADATA\n([\s\S]*?)\n-->/);
                if (match) {
                try {
                    metadata = JSON.parse(match[1]);
                    break;
                } catch (e) {
                    core.warning(`Failed to parse metadata: ${e.message}`);
                }
                }
            }

            if (!metadata || !metadata.thread_id) {
                core.warning('No Discord thread found for this PR. Skipping.');
                return;
            }

            // Post in thread for the removed reviewer
            if (removedReviewerLogin) {
                const removedReviewerMention = mapToDiscord(removedReviewerLogin);
                await fetch(`https://discord.com/api/v10/channels/${metadata.thread_id}/messages`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bot ${botToken}`,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    content: `üëã ${removedReviewerMention} has been removed as a reviewer from this PR.`
                })
                });
            }

            // Update parent message with ALL current reviewers (after removal)
            try {
                const messageResponse = await fetch(`https://discord.com/api/v10/channels/${metadata.channel_id}/messages/${metadata.message_id}`, {
                method: 'GET',
                headers: {
                    'Authorization': `Bot ${botToken}`
                }
                });
                
                if (messageResponse.ok) {
                const messageData = await messageResponse.json();
                let content = messageData.content;
                
                // Extract the parts before and after the reviewers section
                const lines = content.split('\n');
                let beforeReviewers = [];
                let afterReviewers = [];
                let reviewersLineIndex = -1;
                
                // Find the reviewers line or no reviewers warning
                for (let i = 0; i < lines.length; i++) {
                    if (lines[i].includes('Reviewers:') || lines[i].includes('‚ö†Ô∏è No reviewers assigned')) {
                    reviewersLineIndex = i;
                    break;
                    }
                }
                
                if (reviewersLineIndex >= 0) {
                    beforeReviewers = lines.slice(0, reviewersLineIndex);
                    afterReviewers = lines.slice(reviewersLineIndex + 1);
                } else {
                    // If no reviewers line found, assume it should be after the Author line
                    const authorLineIndex = lines.findIndex(line => line.startsWith('Author:'));
                    if (authorLineIndex >= 0) {
                    beforeReviewers = lines.slice(0, authorLineIndex + 1);
                    afterReviewers = lines.slice(authorLineIndex + 1);
                    } else {
                    beforeReviewers = lines;
                    afterReviewers = [];
                    }
                }
                
                // Rebuild the message with current reviewers
                const rebuiltLines = [...beforeReviewers];
                
                if (allReviewerLogins.length > 0) {
                    const reviewerMentions = allReviewerLogins.map(mapToDiscord).join(' ');
                    rebuiltLines.push(`Reviewers: ${reviewerMentions}`);
                } else {
                    rebuiltLines.push(`\n‚ö†Ô∏è No reviewers assigned. Please add reviewers to this PR.`);
                }
                
                rebuiltLines.push(...afterReviewers);
                content = rebuiltLines.join('\n');
                
                // Edit the message
                await fetch(`https://discord.com/api/v10/channels/${metadata.channel_id}/messages/${metadata.message_id}`, {
                    method: 'PATCH',
                    headers: {
                    'Authorization': `Bot ${botToken}`,
                    'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                    content: content,
                    flags: 4 // Suppress embeds
                    })
                });
                }
            } catch (e) {
                core.warning(`Failed to edit parent message: ${e.message}`);
            }              
